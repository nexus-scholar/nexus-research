import pandas as pd
from pathlib import Path
from nexus.screener.client import LLMClient

class Synthesizer:
    def __init__(self, model: str = "google/gemini-2.0-flash-001"):
        self.client = LLMClient(model=model)

    def generate_review(self, csv_path: Path, output_file: Path):
        if not csv_path.exists():
            return False

        df = pd.read_csv(csv_path)
        
        # Group by category (e.g., Architecture, Data-Centric)
        # If category is missing, fallback to 'General'
        if "category" not in df.columns:
            df["category"] = "General"
        
        # Sort so we have a consistent order
        groups = df.groupby("category")
        
        full_draft = "# Literature Review Draft\n\n*Generated by Nexus*\n\n"
        
        print(f"Synthesizing review from {len(df)} papers...")

        for category, group in groups:
            print(f"  - Writing section: {category} ({len(group)} papers)")
            
            # Prepare context for LLM
            context = ""
            for _, row in group.iterrows():
                context += f"- **Paper**: {row.get('source', 'Unknown')}\n"
                context += f"  - **Focus**: {row.get('research_focus', 'N/A')}\n"
                context += f"  - **Models**: {row.get('models_used', 'N/A')}\n"
                context += f"  - **Key Contribution**: {row.get('key_contribution', 'N/A')}\n"
                context += f"  - **Limitations**: {row.get('limitations', 'N/A')}\n"
                context += f"  - **Results**: {row.get('best_accuracy', 'N/A')}\n\n"

            system_prompt = f"""
            You are an expert academic writer composing a Systematic Literature Review.
            
            Task: Write a cohesive "Related Work" section for the category: "{category}".
            
            Guidelines:
            1. Synthesize the provided papers into a narrative. Do NOT just list them one by one.
            2. Compare and contrast approaches (e.g., "While [Paper A] focused on X, [Paper B] improved this by Y").
            3. Highlight trends and common limitations.
            4. Use the paper filename (e.g., 10.1007_...) as the citation key.
            5. Output purely the section text in Markdown.
            """

            user_prompt = f"Papers to review:\n\n{context}"

            try:
                response = self.client.client.chat.completions.create(
                    model=self.client.model,
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt},
                    ],
                    temperature=0.7
                )
                content = response.choices[0].message.content
                
                full_draft += f"## {category}\n\n{content}\n\n"
                
            except Exception as e:
                print(f"Error synthesizing {category}: {e}")
                full_draft += f"## {category}\n\n*Error generating section.*\n\n"

        # Generate Conclusion / Gaps
        print("  - Writing Research Gaps & Conclusion")
        gap_prompt = """
        Based on the sections you just wrote (implied), verify general research gaps.
        (Actually, I will send a summary of limitations to find gaps).
        """
        
        # Aggregate all limitations
        all_limitations = "\n".join(df["limitations"].dropna().tolist())
        gap_user_prompt = f"Here are the limitations extracted from 200+ papers:\n\n{all_limitations[:50000]}\n\nSummarize the 3-5 major open research gaps in this field."
        
        try:
            response = self.client.client.chat.completions.create(
                model=self.client.model,
                messages=[
                    {"role": "system", "content": "You are identifying research gaps."}, 
                    {"role": "user", "content": gap_user_prompt},
                ]
            )
            full_draft += "## Research Gaps & Future Directions\n\n" + response.choices[0].message.content + "\n"
        except Exception:
            pass

        output_file.write_text(full_draft, encoding="utf-8")
        return True
