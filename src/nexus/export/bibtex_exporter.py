"""
BibTeX exporter for Simple SLR.

This module provides functionality for exporting documents to BibTeX format,
suitable for use with reference managers like Zotero, Mendeley, and LaTeX.
"""

import re
from pathlib import Path
from typing import List, Optional

from nexus.core.models import Document, DocumentCluster
from nexus.export.base import BaseExporter, ExportWriteError


class BibTeXExporter(BaseExporter):
    """Exporter for BibTeX format.

    This exporter converts documents to BibTeX entries, generating
    citation keys and formatting metadata according to BibTeX standards.

    Features:
    - Automatic citation key generation
    - Multiple entry types (@article, @inproceedings, @misc)
    - Proper field escaping
    - DOI and URL inclusion
    - Author formatting

    Example:
        >>> from nexus.export import BibTeXExporter
        >>> from nexus.core.models import Document
        >>>
        >>> exporter = BibTeXExporter(output_dir="outputs")
        >>> exporter.export_documents(documents, "references.bib")
        PosixPath('outputs/references.bib')
    """

    @property
    def file_extension(self) -> str:
        """Get file extension for BibTeX files."""
        return "bib"

    def export_documents(
        self,
        documents: List[Document],
        output_file: str,
        **kwargs
    ) -> Path:
        """Export documents to BibTeX file.

        Args:
            documents: List of documents to export
            output_file: Name of output file (will add .bib if needed)
            **kwargs: Additional options (currently unused)

        Returns:
            Path to created BibTeX file

        Raises:
            ExportWriteError: If writing to file fails
        """
        if not output_file.endswith('.bib'):
            output_file = f"{output_file}.bib"

        output_path = self._get_output_path(output_file)

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                # Write header comment
                f.write("% BibTeX entries generated by Simple SLR\n")
                f.write("% https://github.com/yourusername/simple-slr\n\n")

                for doc in documents:
                    entry = self._document_to_bibtex(doc)
                    f.write(entry)
                    f.write("\n\n")

        except IOError as e:
            raise ExportWriteError(f"Failed to write BibTeX file: {e}") from e

        return output_path

    def export_clusters(
        self,
        clusters: List[DocumentCluster],
        output_file: str,
        **kwargs
    ) -> Path:
        """Export cluster representatives to BibTeX file.

        Args:
            clusters: List of document clusters to export
            output_file: Name of output file (will add .bib if needed)
            **kwargs: Additional options (currently unused)

        Returns:
            Path to created BibTeX file
        """
        # Export representatives only
        representatives = [cluster.representative for cluster in clusters]
        return self.export_documents(representatives, output_file, **kwargs)

    def _document_to_bibtex(self, doc: Document) -> str:
        """Convert a document to BibTeX entry.

        Args:
            doc: Document to convert

        Returns:
            BibTeX entry string
        """
        # Generate citation key
        cite_key = self._generate_cite_key(doc)

        # Determine entry type
        entry_type = self._determine_entry_type(doc)

        # Build entry
        lines = [f"@{entry_type}{{{cite_key},"]

        # Add required fields first
        if doc.title:
            lines.append(f"  title = {{{self._escape_latex(doc.title)}}},")

        if doc.authors:
            author_str = self._format_authors_bibtex(doc.authors)
            lines.append(f"  author = {{{author_str}}},")

        if doc.year:
            lines.append(f"  year = {{{doc.year}}},")

        # Add optional fields
        if doc.venue:
            # Determine if journal or booktitle
            if entry_type == "article":
                lines.append(f"  journal = {{{self._escape_latex(doc.venue)}}},")
            elif entry_type == "inproceedings":
                lines.append(f"  booktitle = {{{self._escape_latex(doc.venue)}}},")
            else:
                lines.append(f"  publisher = {{{self._escape_latex(doc.venue)}}},")

        if doc.abstract:
            # Truncate very long abstracts
            abstract = doc.abstract
            if len(abstract) > 500:
                abstract = abstract[:497] + "..."
            lines.append(f"  abstract = {{{self._escape_latex(abstract)}}},")

        # Add identifiers
        if doc.external_ids.doi:
            lines.append(f"  doi = {{{doc.external_ids.doi}}},")

        if doc.url:
            lines.append(f"  url = {{{doc.url}}},")
        elif doc.external_ids.doi:
            # Generate DOI URL if no URL provided
            lines.append(f"  url = {{https://doi.org/{doc.external_ids.doi}}},")

        # Add arXiv info
        if doc.external_ids.arxiv_id:
            lines.append(f"  eprint = {{{doc.external_ids.arxiv_id}}},")
            lines.append(f"  archivePrefix = {{arXiv}},")

        # Add note with provider info
        notes = []
        if doc.provider:
            notes.append(f"Source: {doc.provider}")
        if doc.cited_by_count:
            notes.append(f"Citations: {doc.cited_by_count}")
        if notes:
            lines.append(f"  note = {{{', '.join(notes)}}},")

        # Remove trailing comma from last field
        if lines[-1].endswith(','):
            lines[-1] = lines[-1][:-1]

        lines.append("}")

        return "\n".join(lines)

    def _generate_cite_key(self, doc: Document) -> str:
        """Generate a citation key for a document.

        Format: FirstAuthorYYYYKeyword
        Example: Smith2020Deep

        Args:
            doc: Document to generate key for

        Returns:
            Citation key string
        """
        parts = []

        # Add first author's last name
        if doc.authors and len(doc.authors) > 0:
            first_author = doc.authors[0]
            if hasattr(first_author, 'family_name') and first_author.family_name:
                # Clean the name
                name = re.sub(r'[^a-zA-Z]', '', first_author.family_name)
                parts.append(name)

        # Add year
        if doc.year:
            parts.append(str(doc.year))

        # Add first significant word from title
        if doc.title:
            # Skip common words
            skip_words = {'a', 'an', 'the', 'on', 'in', 'at', 'of', 'for', 'to', 'and', 'or'}
            words = doc.title.lower().split()
            for word in words:
                # Clean word and check if significant
                clean_word = re.sub(r'[^a-z]', '', word)
                if clean_word and clean_word not in skip_words and len(clean_word) > 2:
                    parts.append(clean_word.capitalize())
                    break

        # Fallback if no parts
        if not parts:
            # Use provider ID or generate random key
            if doc.provider_id:
                clean_id = re.sub(r'[^a-zA-Z0-9]', '', doc.provider_id)
                return clean_id[:20]
            return "UnknownRef"

        key = ''.join(parts)

        # Ensure key is not too long
        if len(key) > 30:
            key = key[:30]

        return key

    def _determine_entry_type(self, doc: Document) -> str:
        """Determine the BibTeX entry type for a document.

        Args:
            doc: Document to analyze

        Returns:
            BibTeX entry type (article, inproceedings, misc, etc.)
        """
        venue_lower = (doc.venue or '').lower()

        # Check for conference/proceedings indicators
        conf_keywords = ['conference', 'proceedings', 'workshop', 'symposium', 'congress']
        if any(keyword in venue_lower for keyword in conf_keywords):
            return 'inproceedings'

        # Check for journal indicators
        journal_keywords = ['journal', 'review', 'magazine', 'transactions']
        if any(keyword in venue_lower for keyword in journal_keywords):
            return 'article'

        # Check provider
        if doc.provider == 'arxiv':
            return 'misc'  # arXiv preprints are typically @misc

        # Check for DOI (usually articles)
        if doc.external_ids.doi:
            return 'article'

        # Default to misc for unknown types
        return 'misc'

    def _format_authors_bibtex(self, authors: List) -> str:
        """Format authors for BibTeX.

        Args:
            authors: List of Author objects

        Returns:
            BibTeX-formatted author string
        """
        if not authors:
            return ''

        author_strs = []
        for author in authors:
            if hasattr(author, 'family_name'):
                if hasattr(author, 'given_name') and author.given_name:
                    # Format: Given Family
                    author_strs.append(f"{author.given_name} {author.family_name}")
                else:
                    author_strs.append(author.family_name)
            else:
                author_strs.append(str(author))

        # Join with 'and' for BibTeX
        return ' and '.join(author_strs)

    def _escape_latex(self, text: str) -> str:
        """Escape special LaTeX characters in text.

        Args:
            text: Text to escape

        Returns:
            Escaped text
        """
        if not text:
            return ''

        # Escape special characters
        replacements = {
            '\\': '\\textbackslash{}',
            '&': '\\&',
            '%': '\\%',
            '$': '\\$',
            '#': '\\#',
            '_': '\\_',
            '{': '\\{',
            '}': '\\}',
            '~': '\\textasciitilde{}',
            '^': '\\textasciicircum{}',
        }

        result = text
        for char, replacement in replacements.items():
            result = result.replace(char, replacement)

        return result

